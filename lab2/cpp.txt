#include "Array.h"
#include <iostream>
#include <stdexcept>

//создание динамического массива 
Array* create_array(int initial_capacity) {
    Array* arr = new Array; 
    arr->data = new string[initial_capacity];
    arr->capacity = initial_capacity;
    arr->size = 0; //первоночальное кол-во элементов
    return arr;
}

//добавление в конец 
void array_push_back(Array* arr, const string& value) {
    //проверка для увеличения памяти
    if (arr->size >= arr->capacity) {
        int new_capacity = arr->capacity * 2;
        string* new_data = new string[new_capacity];
        
        for (int i = 0; i < arr->size; i++) {
            new_data[i] = arr->data[i];
        }
        
        delete[] arr->data;
        arr->data = new_data;
        arr->capacity = new_capacity;
    }
    
    //добавление элементов и увеличение счетчика размера
    arr->data[arr->size] = value;
    arr->size++;
}

//вставка по индексу 
bool array_insert(Array* arr, int index, const string& value) {
    //проверка на значения индекса
    if (index < 0 || index > arr->size) {
        return false; 
    }
    
    //увеличение массива, если заполнен
    if (arr->size >= arr->capacity) {
        int new_capacity = arr->capacity * 2;
        string* new_data = new string[new_capacity];
        
        for (int i = 0; i < index; i++) {
            new_data[i] = arr->data[i];
        }
        
        new_data[index] = value;
        
        for (int i = index; i < arr->size; i++) {
            new_data[i + 1] = arr->data[i];
        }
        
        //замена старого на новый
        delete[] arr->data;
        arr->data = new_data;
        arr->capacity = new_capacity;
    } else {
        // Сдвигаем элементы вправо
        for (int i = arr->size; i > index; i--) {
            arr->data[i] = arr->data[i - 1];
        }
        arr->data[index] = value; //добавление элемента
    }
    
    arr->size++;
    return true;
}

//поиск по индексу 
string array_get(const Array* arr, int index) {
    //проверка индекса
    if (index < 0 || index >= arr->size) {
        return ""; // Пустая строка при неверном индексе
    }
    return arr->data[index];
}

//удаление по индексу
bool array_remove(Array* arr, int index) {
    //проверка индекса
    if (index < 0 || index >= arr->size) {
        return false;
    }
    
    //сдвиг элементов влево
    for (int i = index; i < arr->size - 1; i++) {
        arr->data[i] = arr->data[i + 1];
    }
    
    arr->size--; //уменьшение размера
    return true;
}

//вставка по индексу 
bool array_replace(Array* arr, int index, const string& value) {
    //проверка индекса
    if (index < 0 || index >= arr->size) {
        return false;
    }
    
    arr->data[index] = value; //заменв
    return true;
}

//вывод кол-ва элементов 
int array_length(const Array* arr) {
    return arr->size;
}

//вывод массива
void array_print(const Array* arr) {
    if (arr->size == 0) {
        cout << "массив пуст" << endl;
        return;
    }
    
    cout << "массив [" << arr->size << "]: ";
    //вывод элементов
    for (int i = 0; i < arr->size; i++) {
        cout << arr->data[i];
        if (i < arr->size - 1) {
            cout << ", ";
        }
    }
    cout << endl;
}

//очистка памяти
void array_free(Array* arr) {
    delete[] arr->data;
    delete arr;
}


#include "DB.h"
#include "Array.h"
#include "SingleList.h"
#include "DoubleList.h"
#include "Stack.h"
#include "Queue.h"
#include "FBT.h"
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <queue>

Database* create_database() {
    return new Database;
}

//освобождение памяти
void free_database(Database* db) {
    // Освобождаем массивы
    for (auto& pair : db->arrays) {
        array_free(static_cast<Array*>(pair.second));
    }
    
    // Освобождаем односвязные списки
    for (auto& pair : db->singly_lists) {
        sll_free(static_cast<SingleList*>(pair.second));
    }
    
    // Освобождаем двусвязные списки
    for (auto& pair : db->doubly_lists) {
        dll_free(static_cast<DoubleList*>(pair.second));
    }
    
    // Освобождаем стеки
    for (auto& pair : db->stacks) {
        stack_free(static_cast<Stack*>(pair.second));
    }
    
    // Освобождаем очереди
    for (auto& pair : db->queues) {
        queue_free(static_cast<Queue*>(pair.second));
    }
    
    // Освобождаем деревья
    for (auto& pair : db->trees) {
        tree_free(static_cast<FullBinaryTree*>(pair.second));
    }
    
    delete db;
}

//сохранене в бд
bool save_database(const Database* db, const string& filename) {
    ofstream file(filename);
    if (!file.is_open()) {
        return false;
    }
    
    // Сохраняем массивы
    for (const auto& pair : db->arrays) {
        const Array* arr = static_cast<const Array*>(pair.second);
        file << "ARRAY " << pair.first << " " << array_length(arr) << " ";
        for (int i = 0; i < array_length(arr); i++) {
            file << array_get(arr, i) << " ";
        }
        file << "\n";
    }
    
    // Сохраняем односвязные списки
    for (const auto& pair : db->singly_lists) {
        const SingleList* list = static_cast<const SingleList*>(pair.second);
        file << "SINGLY_LIST " << pair.first << " " << sll_size(list) << " ";
        SNode* current = list->head;
        while (current != nullptr) {
            file << current->data << " ";
            current = current->next;
        }
        file << "\n";
    }
    
    // Сохраняем двусвязные списки
    for (const auto& pair : db->doubly_lists) {
        const DoubleList* list = static_cast<const DoubleList*>(pair.second);
        file << "DOUBLY_LIST " << pair.first << " " << dll_size(list) << " ";
        DNode* current = list->head;
        while (current != nullptr) {
            file << current->data << " ";
            current = current->next;
        }
        file << "\n";
    }
    
    // Сохраняем стеки
    for (const auto& pair : db->stacks) {
        const Stack* stack = static_cast<const Stack*>(pair.second);
        file << "STACK " << pair.first << " " << stack_size(stack) << " ";
        // Для стека сохраняем в обратном порядке
        vector<string> elements;
        const Stack* original = stack;
        
        // Копируем стек
        Stack* copy = create_stack(original->capacity);
        copy->top = original->top;
        for (int i = 0; i <= original->top; i++) {
            copy->data[i] = original->data[i];
        }
        
        while (!stack_is_empty(copy)) {
            elements.push_back(stack_pop(copy));
        }
        
        for (auto it = elements.rbegin(); it != elements.rend(); ++it) {
            file << *it << " ";
        }
        stack_free(copy);
        file << "\n";
    }
    
    // Сохраняем очереди
    for (const auto& pair : db->queues) {
        const Queue* queue = static_cast<const Queue*>(pair.second);
        file << "QUEUE " << pair.first << " " << queue_size(queue) << " ";
        for (int i = 0; i < queue_size(queue); i++) {
            int index = (queue->front + i) % queue->capacity;
            file << queue->data[index] << " ";
        }
        file << "\n";
    }
    
    // Сохраняем деревья
    for (const auto& pair : db->trees) {
        const FullBinaryTree* tree = static_cast<const FullBinaryTree*>(pair.second);
        file << "TREE " << pair.first << " " << tree_size(tree) << " ";
        
        // Сохраняем дерево в порядке уровней
        if (tree->root != nullptr) {
            queue<const TreeNode*> q;
            q.push(tree->root);
            
            while (!q.empty()) {
                const TreeNode* current = q.front();
                q.pop();
                
                file << current->key << " " << current->value << " ";
                
                if (current->left != nullptr) {
                    q.push(current->left);
                }
                if (current->right != nullptr) {
                    q.push(current->right);
                }
            }
        }
        file << "\n";
    }
    
    file.close();
    return true;
}

bool load_database(Database* db, const string& filename) {
    ifstream file(filename);
    if (!file.is_open()) {
        return false;
    }
    
    string line;
    while (getline(file, line)) {
        istringstream iss(line);
        string type, name;
        int size;
        
        iss >> type >> name >> size;
        
        if (type == "ARRAY") {
            Array* arr = create_array(size);
            string value;
            for (int i = 0; i < size; i++) {
                iss >> value;
                array_push_back(arr, value);
            }
            db->arrays[name] = arr;
        }
        else if (type == "SINGLY_LIST") {
            SingleList* list = create_singly_linked_list();
            string value;
            for (int i = 0; i < size; i++) {
                iss >> value;
                sll_push_back(list, value);
            }
            db->singly_lists[name] = list;
        }
        else if (type == "DOUBLY_LIST") {
            DoubleList* list = create_doubly_linked_list();
            string value;
            for (int i = 0; i < size; i++) {
                iss >> value;
                dll_push_back(list, value);
            }
            db->doubly_lists[name] = list;
        }
        else if (type == "STACK") {
            Stack* stack = create_stack(size);
            string value;
            for (int i = 0; i < size; i++) {
                iss >> value;
                stack_push(stack, value);
            }
            db->stacks[name] = stack;
        }
        else if (type == "QUEUE") {
            Queue* queue = create_queue(size);
            string value;
            for (int i = 0; i < size; i++) {
                iss >> value;
                queue_push(queue, value);
            }
            db->queues[name] = queue;
        }
        else if (type == "TREE") {
            FullBinaryTree* tree = create_full_binary_tree();
            int key;
            string value;
            
            for (int i = 0; i < size; i++) {
                iss >> key >> value;
                tree_insert(tree, key, value);
            }
            db->trees[name] = tree;
        }
    }
    
    file.close();
    return true;
}

// Вспомогательные функции для разбора команд
vector<string> split_command(const string& command) {
    vector<string> tokens;
    istringstream iss(command);
    string token;
    
    while (iss >> token) {
        tokens.push_back(token);
    }
    
    return tokens;
}

string execute_command(Database* db, const string& command) {
    vector<string> tokens = split_command(command);
    
    if (tokens.empty()) {
        return "ERROR: Empty command";
    }
    
    string cmd = tokens[0];
    
    // Команда PRINT для любого контейнера
    if (cmd == "PRINT") {
        if (tokens.size() < 2) {
            return "ERROR: PRINT requires container name";
        }
        
        string container_name = tokens[1];
        
        // Проверяем все типы контейнеров
        if (db->arrays.find(container_name) != db->arrays.end()) {
            Array* arr = static_cast<Array*>(db->arrays[container_name]);
            array_print(arr);
            return "SUCCESS";
        }
        else if (db->singly_lists.find(container_name) != db->singly_lists.end()) {
            SingleList* list = static_cast<SingleList*>(db->singly_lists[container_name]);
            sll_print_forward(list);
            return "SUCCESS";
        }
        else if (db->doubly_lists.find(container_name) != db->doubly_lists.end()) {
            DoubleList* list = static_cast<DoubleList*>(db->doubly_lists[container_name]);
            dll_print_forward(list);
            return "SUCCESS";
        }
        else if (db->stacks.find(container_name) != db->stacks.end()) {
            Stack* stack = static_cast<Stack*>(db->stacks[container_name]);
            stack_print(stack);
            return "SUCCESS";
        }
        else if (db->queues.find(container_name) != db->queues.end()) {
            Queue* queue = static_cast<Queue*>(db->queues[container_name]);
            queue_print(queue);
            return "SUCCESS";
        }
        else if (db->trees.find(container_name) != db->trees.end()) {
            FullBinaryTree* tree = static_cast<FullBinaryTree*>(db->trees[container_name]);
            tree_print(tree);
            return "SUCCESS";
        }
        else {
            return "ERROR: Container not found: " + container_name;
        }
    }
    
    // Обработка команд для массивов (M)
    else if (cmd.substr(0, 1) == "M") {
        if (tokens.size() < 2) {
            return "ERROR: Array command requires container name";
        }
        
        string array_name = tokens[1];
        
        if (cmd == "MCREATE") {
            if (db->arrays.find(array_name) != db->arrays.end()) {
                return "ERROR: Array already exists: " + array_name;
            }
            db->arrays[array_name] = create_array();
            return "SUCCESS: Array created: " + array_name;
        }
        else if (cmd == "MPUSH") {
            if (tokens.size() < 3) {
                return "ERROR: MPUSH requires value";
            }
            if (db->arrays.find(array_name) == db->arrays.end()) {
                return "ERROR: Array not found: " + array_name;
            }
            Array* arr = static_cast<Array*>(db->arrays[array_name]);
            array_push_back(arr, tokens[2]);
            return "SUCCESS: Value pushed to array";
        }
        else if (cmd == "MINSERT") {
            if (tokens.size() < 4) {
                return "ERROR: MINSERT requires index and value";
            }
            if (db->arrays.find(array_name) == db->arrays.end()) {
                return "ERROR: Array not found: " + array_name;
            }
            int index = stoi(tokens[2]);
            Array* arr = static_cast<Array*>(db->arrays[array_name]);
            if (array_insert(arr, index, tokens[3])) {
                return "SUCCESS: Value inserted at index " + tokens[2];
            } else {
                return "ERROR: Invalid index";
            }
        }
        else if (cmd == "MGET") {
            if (tokens.size() < 3) {
                return "ERROR: MGET requires index";
            }
            if (db->arrays.find(array_name) == db->arrays.end()) {
                return "ERROR: Array not found: " + array_name;
            }
            int index = stoi(tokens[2]);
            Array* arr = static_cast<Array*>(db->arrays[array_name]);
            string value = array_get(arr, index);
            if (!value.empty()) {
                return "VALUE: " + value;
            } else {
                return "ERROR: Invalid index or empty value";
            }
        }
        else if (cmd == "MDEL") {
            if (tokens.size() < 3) {
                return "ERROR: MDEL requires index";
            }
            if (db->arrays.find(array_name) == db->arrays.end()) {
                return "ERROR: Array not found: " + array_name;
            }
            int index = stoi(tokens[2]);
            Array* arr = static_cast<Array*>(db->arrays[array_name]);
            if (array_remove(arr, index)) {
                return "SUCCESS: Element removed at index " + tokens[2];
            } else {
                return "ERROR: Invalid index";
            }
        }
        else if (cmd == "MREPLACE") {
            if (tokens.size() < 4) {
                return "ERROR: MREPLACE requires index and value";
            }
            if (db->arrays.find(array_name) == db->arrays.end()) {
                return "ERROR: Array not found: " + array_name;
            }
            int index = stoi(tokens[2]);
            Array* arr = static_cast<Array*>(db->arrays[array_name]);
            if (array_replace(arr, index, tokens[3])) {
                return "SUCCESS: Value replaced at index " + tokens[2];
            } else {
                return "ERROR: Invalid index";
            }
        }
        else if (cmd == "MSIZE") {
            if (db->arrays.find(array_name) == db->arrays.end()) {
                return "ERROR: Array not found: " + array_name;
            }
            Array* arr = static_cast<Array*>(db->arrays[array_name]);
            return "SIZE: " + to_string(array_length(arr));
        }
    }
    
    // Обработка команд для односвязных списков (F)
    else if (cmd.substr(0, 1) == "F") {
        if (tokens.size() < 2) {
            return "ERROR: Singly list command requires container name";
        }
        
        string list_name = tokens[1];
        
        if (cmd == "FCREATE") {
            if (db->singly_lists.find(list_name) != db->singly_lists.end()) {
                return "ERROR: Singly list already exists: " + list_name;
            }
            db->singly_lists[list_name] = create_singly_linked_list();
            return "SUCCESS: Singly list created: " + list_name;
        }
        else if (cmd == "FPUSH") {
            if (tokens.size() < 4) {
                return "ERROR: FPUSH requires type and value";
            }
            if (db->singly_lists.find(list_name) == db->singly_lists.end()) {
                return "ERROR: Singly list not found: " + list_name;
            }
            
            string push_type = tokens[2];
            SingleList* list = static_cast<SingleList*>(db->singly_lists[list_name]);
            
            if (push_type == "FRONT") {
                string value = tokens[3];
                sll_push_front(list, value);
                return "SUCCESS: Value pushed to front";
            }
            else if (push_type == "BACK") {
                string value = tokens[3];
                sll_push_back(list, value);
                return "SUCCESS: Value pushed to back";
            }
            else if (push_type == "BEFORE") {
                if (tokens.size() < 5) {
                    return "ERROR: FPUSH BEFORE requires target value";
                }
                string target = tokens[3];
                string value = tokens[4];
                if (sll_insert_before(list, target, value)) {
                    return "SUCCESS: Value inserted before target";
                } else {
                    return "ERROR: Target not found";
                }
            }
            else if (push_type == "AFTER") {
                if (tokens.size() < 5) {
                    return "ERROR: FPUSH AFTER requires target value";
                }
                string target = tokens[3];
                string value = tokens[4];
                if (sll_insert_after(list, target, value)) {
                    return "SUCCESS: Value inserted after target";
                } else {
                    return "ERROR: Target not found";
                }
            }
            else {
                return "ERROR: Invalid push type. Use FRONT/BACK/BEFORE/AFTER";
            }
        }
        else if (cmd == "FDEL") {
            if (tokens.size() < 3) {
                return "ERROR: FDEL requires type";
            }
            if (db->singly_lists.find(list_name) == db->singly_lists.end()) {
                return "ERROR: Singly list not found: " + list_name;
            }
            
            string del_type = tokens[2];
            SingleList* list = static_cast<SingleList*>(db->singly_lists[list_name]);
            
            if (del_type == "FRONT") {
                if (sll_pop_front(list)) {
                    return "SUCCESS: Front element removed";
                } else {
                    return "ERROR: List is empty";
                }
            }
            else if (del_type == "BACK") {
                if (sll_pop_back(list)) {
                    return "SUCCESS: Back element removed";
                } else {
                    return "ERROR: List is empty";
                }
            }
            else if (del_type == "VALUE") {
                if (tokens.size() < 4) {
                    return "ERROR: FDEL VALUE requires target value";
                }
                if (sll_remove_value(list, tokens[3])) {
                    return "SUCCESS: Value removed";
                } else {
                    return "ERROR: Value not found";
                }
            }
            else if (del_type == "BEFORE") {
                if (tokens.size() < 4) {
                    return "ERROR: FDEL BEFORE requires target value";
                }
                if (sll_remove_value(list, tokens[3])) {
                    return "SUCCESS: Element before target removed";
                } else {
                    return "ERROR: Cannot remove before target";
                }
            }
            else if (del_type == "AFTER") {
                if (tokens.size() < 4) {
                    return "ERROR: FDEL AFTER requires target value";
                }
                if (sll_remove_value(list, tokens[3])) {
                    return "SUCCESS: Element after target removed";
                } else {
                    return "ERROR: Cannot remove after target";
                }
            }
            else {
                return "ERROR: Invalid delete type. Use FRONT/BACK/VALUE/BEFORE/AFTER";
            }
        }
        else if (cmd == "FGET") {
            if (db->singly_lists.find(list_name) == db->singly_lists.end()) {
                return "ERROR: Singly list not found: " + list_name;
            }
            SingleList* list = static_cast<SingleList*>(db->singly_lists[list_name]);
            
            if (tokens.size() == 2) {
                // Возвращаем весь список
                string result = "LIST: ";
                SNode* current = list->head;
                while (current != nullptr) {
                    result += current->data;
                    if (current->next != nullptr) result += " -> ";
                    current = current->next;
                }
                return result;
            }
            else if (tokens.size() == 3) {
                // Поиск элемента
                SNode* found = sll_find(list, tokens[2]);
                if (found) {
                    return "FOUND: " + found->data;
                } else {
                    return "NOT_FOUND";
                }
            }
            else {
                return "ERROR: FGET requires either no arguments (to display list) or one argument (to search)";
            }
        }
        else if (cmd == "FSIZE") {
            if (db->singly_lists.find(list_name) == db->singly_lists.end()) {
                return "ERROR: Singly list not found: " + list_name;
            }
            SingleList* list = static_cast<SingleList*>(db->singly_lists[list_name]);
            return "SIZE: " + to_string(sll_size(list));
        }
        else if (cmd == "FPRINT_BACKWARD") {
            if (db->singly_lists.find(list_name) == db->singly_lists.end()) {
                return "ERROR: Singly list not found: " + list_name;
            }
            SingleList* list = static_cast<SingleList*>(db->singly_lists[list_name]);
            sll_print_backward(list);
            return "SUCCESS";
        }
    }
    
    // Обработка команд для двусвязных списков (L)
    else if (cmd.substr(0, 1) == "L") {
        if (tokens.size() < 2) {
            return "ERROR: Doubly list command requires container name";
        }
        
        string list_name = tokens[1];
        
        if (cmd == "LCREATE") {
            if (db->doubly_lists.find(list_name) != db->doubly_lists.end()) {
                return "ERROR: Doubly list already exists: " + list_name;
            }
            db->doubly_lists[list_name] = create_doubly_linked_list();
            return "SUCCESS: Doubly list created: " + list_name;
        }
        else if (cmd == "LPUSH") {
            if (tokens.size() < 4) {
                return "ERROR: LPUSH requires type and value";
            }
            if (db->doubly_lists.find(list_name) == db->doubly_lists.end()) {
                return "ERROR: Doubly list not found: " + list_name;
            }
            
            string push_type = tokens[2];
            string value = tokens[3];
            DoubleList* list = static_cast<DoubleList*>(db->doubly_lists[list_name]);
            
            if (push_type == "FRONT") {
                dll_push_front(list, value);
                return "SUCCESS: Value pushed to front";
            }
            else if (push_type == "BACK") {
                dll_push_back(list, value);
                return "SUCCESS: Value pushed to back";
            }
            else if (push_type == "BEFORE") {
                if (tokens.size() < 5) {
                    return "ERROR: LPUSH BEFORE requires target value";
                }
                string target = tokens[3];
                string value = tokens[4];
                if (dll_insert_before(list, target, value)) {
                    return "SUCCESS: Value inserted before target";
                } else {
                    return "ERROR: Target not found";
                }
            }
            else if (push_type == "AFTER") {
                if (tokens.size() < 5) {
                    return "ERROR: LPUSH AFTER requires target value";
                }
                string target = tokens[3];
                string value = tokens[4];
                if (dll_insert_after(list, target, value)) {
                    return "SUCCESS: Value inserted after target";
                } else {
                    return "ERROR: Target not found";
                }
            }
            else {
                return "ERROR: Invalid push type. Use FRONT/BACK/BEFORE/AFTER";
            }
        }
        else if (cmd == "LDEL") {
            if (tokens.size() < 3) {
                return "ERROR: LDEL requires type";
            }
            if (db->doubly_lists.find(list_name) == db->doubly_lists.end()) {
                return "ERROR: Doubly list not found: " + list_name;
            }
            
            string del_type = tokens[2];
            DoubleList* list = static_cast<DoubleList*>(db->doubly_lists[list_name]);
            
            if (del_type == "FRONT") {
                if (dll_pop_front(list)) {
                    return "SUCCESS: Front element removed";
                } else {
                    return "ERROR: List is empty";
                }
            }
            else if (del_type == "BACK") {
                if (dll_pop_back(list)) {
                    return "SUCCESS: Back element removed";
                } else {
                    return "ERROR: List is empty";
                }
            }
            else if (del_type == "VALUE") {
                if (tokens.size() < 4) {
                    return "ERROR: LDEL VALUE requires target value";
                }
                if (dll_remove_value(list, tokens[3])) {
                    return "SUCCESS: Value removed";
                } else {
                    return "ERROR: Value not found";
                }
            }
            else if (del_type == "BEFORE"){
                if (tokens.size() < 4){
                    return "ERROR: LDEL BEFORE requires target value";
                }
                if(dll_remove_before(list, tokens[3])){
                     return "SUCCESS: Value removed";
                }else {
                    return "ERROR: Value not found";
                }
            }
            else if (del_type == "AFTER"){
                if (tokens.size() < 4){
                    return "ERROR: LDEL BEFORE requires target value";
                }
                if(dll_remove_after(list, tokens[3])){
                     return "SUCCESS: Value removed";
                }else {
                    return "ERROR: Value not found";
                }
            }
            else {
                return "ERROR: Invalid delete type. Use FRONT/BACK/VALUE";
            }
        }
        else if (cmd == "LGET") {
            if (db->doubly_lists.find(list_name) == db->doubly_lists.end()) {
                return "ERROR: Doubly list not found: " + list_name;
            }
            DoubleList* list = static_cast<DoubleList*>(db->doubly_lists[list_name]);
            
            if (tokens.size() == 2) {
                // Возвращаем весь список
                string result = "LIST: ";
                DNode* current = list->head;
                while (current != nullptr) {
                    result += current->data;
                    if (current->next != nullptr) result += " <-> ";
                    current = current->next;
                }
                return result;
            }
            else if (tokens.size() == 3) {
                // Поиск элемента
                DNode* found = dll_find(list, tokens[2]);
                if (found) {
                    return "FOUND: " + found->data;
                } else {
                    return "NOT_FOUND";
                }
            }
        }
        else if (cmd == "LPRINT_BACKWARD") {
            if (db->doubly_lists.find(list_name) == db->doubly_lists.end()) {
                return "ERROR: Doubly list not found: " + list_name;
            }
            DoubleList* list = static_cast<DoubleList*>(db->doubly_lists[list_name]);
            dll_print_backward(list);
            return "SUCCESS";
        }
        else if (cmd == "LSIZE") {
            if (db->doubly_lists.find(list_name) == db->doubly_lists.end()) {
                return "ERROR: Doubly list not found: " + list_name;
            }
            DoubleList* list = static_cast<DoubleList*>(db->doubly_lists[list_name]);
            return "SIZE: " + to_string(dll_size(list));
        }
    }
    
    // Обработка команд для стеков (S)
    else if (cmd.substr(0, 1) == "S") {
        if (tokens.size() < 2) {
            return "ERROR: Stack command requires container name";
        }
        
        string stack_name = tokens[1];
        
        if (cmd == "SCREATE") {
            if (db->stacks.find(stack_name) != db->stacks.end()) {
                return "ERROR: Stack already exists: " + stack_name;
            }
            db->stacks[stack_name] = create_stack();
            return "SUCCESS: Stack created: " + stack_name;
        }
        else if (cmd == "SPUSH") {
            if (tokens.size() < 3) {
                return "ERROR: SPUSH requires value";
            }
            if (db->stacks.find(stack_name) == db->stacks.end()) {
                return "ERROR: Stack not found: " + stack_name;
            }
            Stack* stack = static_cast<Stack*>(db->stacks[stack_name]);
            stack_push(stack, tokens[2]);
            return "SUCCESS: Value pushed to stack";
        }
        else if (cmd == "SPOP") {
            if (db->stacks.find(stack_name) == db->stacks.end()) {
                return "ERROR: Stack not found: " + stack_name;
            }
            Stack* stack = static_cast<Stack*>(db->stacks[stack_name]);
            string value = stack_pop(stack);
            if (!value.empty()) {
                return "POPPED: " + value;
            } else {
                return "ERROR: Stack is empty";
            }
        }
        else if (cmd == "SPEEK") {
            if (db->stacks.find(stack_name) == db->stacks.end()) {
                return "ERROR: Stack not found: " + stack_name;
            }
            Stack* stack = static_cast<Stack*>(db->stacks[stack_name]);
            string value = stack_peek(stack);
            if (!value.empty()) {
                return "PEEK: " + value;
            } else {
                return "ERROR: Stack is empty";
            }
        }
        else if (cmd == "SSIZE") {
            if (db->stacks.find(stack_name) == db->stacks.end()) {
                return "ERROR: Stack not found: " + stack_name;
            }
            Stack* stack = static_cast<Stack*>(db->stacks[stack_name]);
            return "SIZE: " + to_string(stack_size(stack));
        }
    }
    
    // Обработка команд для очередей (Q)
    else if (cmd.substr(0, 1) == "Q") {
        if (tokens.size() < 2) {
            return "ERROR: Queue command requires container name";
        }
        
        string queue_name = tokens[1];
        
        if (cmd == "QCREATE") {
            if (db->queues.find(queue_name) != db->queues.end()) {
                return "ERROR: Queue already exists: " + queue_name;
            }
            db->queues[queue_name] = create_queue();
            return "SUCCESS: Queue created: " + queue_name;
        }
        else if (cmd == "QPUSH") {
            if (tokens.size() < 3) {
                return "ERROR: QPUSH requires value";
            }
            if (db->queues.find(queue_name) == db->queues.end()) {
                return "ERROR: Queue not found: " + queue_name;
            }
            Queue* queue = static_cast<Queue*>(db->queues[queue_name]);
            queue_push(queue, tokens[2]);
            return "SUCCESS: Value pushed to queue";
        }
        else if (cmd == "QPOP") {
            if (db->queues.find(queue_name) == db->queues.end()) {
                return "ERROR: Queue not found: " + queue_name;
            }
            Queue* queue = static_cast<Queue*>(db->queues[queue_name]);
            string value = queue_pop(queue);
            if (!value.empty()) {
                return "POPPED: " + value;
            } else {
                return "ERROR: Queue is empty";
            }
        }
        else if (cmd == "QPEEK") {
            if (db->queues.find(queue_name) == db->queues.end()) {
                return "ERROR: Queue not found: " + queue_name;
            }
            Queue* queue = static_cast<Queue*>(db->queues[queue_name]);
            string value = queue_peek(queue);
            if (!value.empty()) {
                return "PEEK: " + value;
            } else {
                return "ERROR: Queue is empty";
            }
        }
        else if (cmd == "QSIZE") {
            if (db->queues.find(queue_name) == db->queues.end()) {
                return "ERROR: Queue not found: " + queue_name;
            }
            Queue* queue = static_cast<Queue*>(db->queues[queue_name]);
            return "SIZE: " + to_string(queue_size(queue));
        }
    }
    
    // Обработка команд для деревьев (T)
    else if (cmd.substr(0, 1) == "T") {
        if (tokens.size() < 2) {
            return "ERROR: Tree command requires container name";
        }
        
        string tree_name = tokens[1];
        
        if (cmd == "TCREATE") {
            if (db->trees.find(tree_name) != db->trees.end()) {
                return "ERROR: Tree already exists: " + tree_name;
            }
            db->trees[tree_name] = create_full_binary_tree();
            return "SUCCESS: Tree created: " + tree_name;
        }
        else if (cmd == "TINSERT") {
            if (tokens.size() < 4) {
                return "ERROR: TINSERT requires key and value";
            }
            if (db->trees.find(tree_name) == db->trees.end()) {
                return "ERROR: Tree not found: " + tree_name;
            }
            
            int key;
            try {
                key = stoi(tokens[2]);
            } catch (const exception& e) {
                return "ERROR: Invalid key format";
            }
            
            FullBinaryTree* tree = static_cast<FullBinaryTree*>(db->trees[tree_name]);
            if (tree_insert(tree, key, tokens[3])) {
                return "SUCCESS: Value inserted with key " + tokens[2];
            } else {
                return "ERROR: Failed to insert value";
            }
        }
        else if (cmd == "TSEARCH") {
            if (tokens.size() < 3) {
                return "ERROR: TSEARCH requires key";
            }
            if (db->trees.find(tree_name) == db->trees.end()) {
                return "ERROR: Tree not found: " + tree_name;
            }
            
            int key;
            try {
                key = stoi(tokens[2]);
            } catch (const exception& e) {
                return "ERROR: Invalid key format";
            }
            
            FullBinaryTree* tree = static_cast<FullBinaryTree*>(db->trees[tree_name]);
            string value = tree_search(tree, key);
            if (!value.empty()) {
                return "FOUND: " + value;
            } else {
                return "NOT_FOUND";
            }
        }
        else if (cmd == "TISFULL") {
            if (db->trees.find(tree_name) == db->trees.end()) {
                return "ERROR: Tree not found: " + tree_name;
            }
            
            FullBinaryTree* tree = static_cast<FullBinaryTree*>(db->trees[tree_name]);
            bool is_full = is_full_binary_tree(tree);
            return "IS_FULL: " + string(is_full ? "YES" : "NO");
        }
        else if (cmd == "THEIGHT") {
            if (db->trees.find(tree_name) == db->trees.end()) {
                return "ERROR: Tree not found: " + tree_name;
            }
            
            FullBinaryTree* tree = static_cast<FullBinaryTree*>(db->trees[tree_name]);
            int height = tree_height(tree->root);
            return "HEIGHT: " + to_string(height);
        }
        else if (cmd == "TSIZE") {
            if (db->trees.find(tree_name) == db->trees.end()) {
                return "ERROR: Tree not found: " + tree_name;
            }
            
            FullBinaryTree* tree = static_cast<FullBinaryTree*>(db->trees[tree_name]);
            return "SIZE: " + to_string(tree_size(tree));
        }
        else if (cmd == "TTRAVERSE") {
            if (tokens.size() < 3) {
                return "ERROR: TTRAVERSE requires type (INORDER/PREORDER/POSTORDER/LEVEL)";
            }
            if (db->trees.find(tree_name) == db->trees.end()) {
                return "ERROR: Tree not found: " + tree_name;
            }
            
            FullBinaryTree* tree = static_cast<FullBinaryTree*>(db->trees[tree_name]);
            string traverse_type = tokens[2];
            
            if (traverse_type == "INORDER") {
                tree_inorder(tree);
                return "SUCCESS";
            }
            else if (traverse_type == "PREORDER") {
                tree_preorder(tree);
                return "SUCCESS";
            }
            else if (traverse_type == "POSTORDER") {
                tree_postorder(tree);
                return "SUCCESS";
            }
            else if (traverse_type == "LEVEL") {
                tree_level_order(tree);
                return "SUCCESS";
            }
            else {
                return "ERROR: Invalid traverse type. Use INORDER/PREORDER/POSTORDER/LEVEL";
            }
        }
    }
    
    // Команды управления базой данных
    else if (cmd == "SAVE" || cmd == "save") {
        if (tokens.size() < 2) {
            return "ERROR: SAVE requires filename";
        }
        if (save_database(db, tokens[1])) {
            return "SUCCESS: Database saved to " + tokens[1];
        } else {
            return "ERROR: Failed to save database";
        }
    }
    else if (cmd == "LOAD" || cmd == "load") {
        if (tokens.size() < 2) {
            return "ERROR: LOAD requires filename";
        }
        if (load_database(db, tokens[1])) {
            return "SUCCESS: Database loaded from " + tokens[1];
        } else {
            return "ERROR: Failed to load database";
        }
    }
    else if (cmd == "HELP" || cmd == "help") {
        return "COMMANDS:\n"
               "PRINT <container> - Print any container\n"
               "MCREATE <имя> - Create array\n"
               "MPUSH <имя> <значение> - Push to array\n"
               "MINSERT <имя> <индекс> <значение> - Insert into array\n"
               "MREPLACE <имя> <индекс> <значение> - Replace element at index\n"
               "MGET <имя> <индекс> - Get from array\n"
               "MDEL <имя> <индекс> - Delete from array\n"
               "FCREATE <имя> - Create singly list\n"
               "FPUSH <имя> <тип> <target> <value> - Push to list (types: FRONT/BACK/BEFORE/AFTER)\n"
               "FDEL <имя> <тип> [значение] - Delete from list\n"
               "FGET <имя> <индекс> - Get from list\n"
               "LCREATE <имя> - Create doubly list\n"
               "LPUSH <имя> <тип> <target> <value> - Push to list (types: FRONT/BACK/BEFORE/AFTER)\n"
               "LDEL <имя> <тип> [значение] - Delete from list\n"
               "LGET <имя> <индекс> - Get from list\n"
               "SCREATE <имя> - Create stack\n"
               "SPUSH <имя> <значение> - Push to stack\n"
               "SPOP <имя> - Pop from stack\n"
               "QCREATE <имя> - Create queue\n"
               "QPUSH <имя> <значение> - Push to queue\n"
               "QPOP <имя> - Pop from queue\n"
               "TCREATE <имя> - Create full binary tree\n"
               "TINSERT <имя> <ключ> <значение> - Insert into tree\n"
               "TSEARCH <имя> <ключ> - Search in tree\n"
               "TISFULL <имя> - Check if tree is full\n"
               "TTRAVERSE <имя> <тип> - Traverse tree\n"
               "SAVE <filename> - Save database\n"
               "LOAD <filename> - Load database\n"
               "HELP - Show this help";
    }
    
    // Обработка неизвестных команд
    return "ERROR: Unknown command: " + cmd;
}



#include "DoubleList.h"
#include <iostream>

//создание двусвязного списка
DoubleList* create_doubly_linked_list() {
    DoubleList* list = new DoubleList;
    list->head = nullptr;
    list->tail = nullptr;
    list->size = 0;
    return list;
}

//добавление в голову
void dll_push_front(DoubleList* list, const string& value) {
    DNode* new_node = new DNode;
    new_node->data = value;
    new_node->prev = nullptr; //новый=голова
    new_node->next = list->head; //узел на старый
    
    //если не пустой, то узел на старую голову
    if (list->head != nullptr) {
        list->head->prev = new_node;
    }
    
    list->head = new_node; //новая голова
    
    //если пуст, то и голова и хвост
    if (list->tail == nullptr) {
        list->tail = new_node;
    }
    list->size++;
}

//в хвост
void dll_push_back(DoubleList* list, const string& value) {
    DNode* new_node = new DNode;
    new_node->data = value;
    new_node->next = nullptr; // новый=хвост
    new_node->prev = list->tail; //узел на старый хвост
    
    if (list->tail != nullptr) { //если не пустой, то обновление узла
        list->tail->next = new_node;
    }
    
    list->tail = new_node; // новый=хвост
    
    if (list->head == nullptr) { //если пустой, то голова и хвост
        list->head = new_node;
    }
    list->size++;
}

//вставка перед 
bool dll_insert_before(DoubleList* list, const string& target, const string& value) {
    //поиск элемента 
    DNode* current = list->head;
    while (current != nullptr && current->data != target) {
        current = current->next;
    }
    
    if (current == nullptr) return false; // не найден
    
    if (current == list->head) { //перед головой
        dll_push_front(list, value);
        return true;
    }
    
    //новый узел
    DNode* new_node = new DNode;
    new_node->data = value;
    new_node->prev = current->prev; //новй указывает на предыдущий 
    new_node->next = current; //слудеющий на новый
    
    current->prev->next = new_node; // следующий от старого на новый
    current->prev = new_node; //предыдущий от нового на новый
    
    list->size++;
    return true;
}

// после узла
bool dll_insert_after(DoubleList* list, const string& target, const string& value) {
    //поиск 
    DNode* current = list->head;
    while (current != nullptr && current->data != target) {
        current = current->next;
    }
    
    if (current == nullptr) return false; // не найден
    
    if (current == list->tail) { //после хвоста
        dll_push_back(list, value);
        return true;
    }
    
    //новый узел
    DNode* new_node = new DNode;
    new_node->data = value;
    new_node->prev = current; 
    new_node->next = current->next; 
    
    current->next->prev = new_node; //предыдущий старого на новый
    current->next = new_node; //следующий старого на новый
    
    list->size++;
    return true;
}

//удаление головы
bool dll_pop_front(DoubleList* list) {
    if (list->head == nullptr) return false; //пустой
    
    DNode* temp = list->head; //запоминаем старую
    list->head = list->head->next;//на след элемент
    
    if (list->head != nullptr) {//не пустой,обновление
        list->head->prev = nullptr;
    } else {//стал пустым, обновление хвоста
        list->tail = nullptr;
    }
    
    delete temp; 
    list->size--;
    return true;
}

//хвоста
bool dll_pop_back(DoubleList* list) {
    if (list->tail == nullptr) return false; //пустой
    
    DNode* temp = list->tail;//запоминаем старый
    list->tail = list->tail->prev;//на предыдущий
    
    if (list->tail != nullptr) {//не пкст,обновление нового хвоста
        list->tail->next = nullptr;
    } else {//если стал пустым, обновление
        list->head = nullptr;
    }
    
    delete temp;
    list->size--;
    return true;
}

//перед узлом
bool dll_remove_before(DoubleList* list, const string& target) {
    //поиск
    DNode* current = list->head;
    while (current != nullptr && current->data != target) {
        current = current->next;
    }
    
    if (current == nullptr || current->prev == nullptr) return false;//нет или нет элементов
    
    DNode* to_remove = current->prev;//узел удаления
    
    if (to_remove == list->head) {//если перед головой
        list->head = current;
        current->prev = nullptr;
    } else {//обновление связей
        to_remove->prev->next = current;
        current->prev = to_remove->prev;
    }
    
    delete to_remove;
    list->size--;
    return true;
}

//после
bool dll_remove_after(DoubleList* list, const string& target) {
    //поиск
    DNode* current = list->head;
    while (current != nullptr && current->data != target) {
        current = current->next;
    }
    
    if (current == nullptr || current->next == nullptr) return false;//нет или нет элементов
    
    DNode* to_remove = current->next;//узел удаления
    
    if (to_remove == list->tail) {//если после хвоста
        list->tail = current;
        current->next = nullptr;
    } else {//обновление связей
        current->next = to_remove->next;
        to_remove->next->prev = current;
    }
    
    delete to_remove;
    list->size--;
    return true;
}

//по значению
bool dll_remove_value(DoubleList* list, const string& value) {
    //поиск
    DNode* current = list->head;
    while (current != nullptr && current->data != value) {
        current = current->next;
    }
    
    if (current == nullptr) return false; // значение не найдено
    
    if (current == list->head) {//голова
        return dll_pop_front(list);
    }
    
    if (current == list->tail) {//хвост
        return dll_pop_back(list);
    }
    
     // Обновляем связи соседних узлов, обходя удаляемый
    current->prev->next = current->next;
    current->next->prev = current->prev;
    
    delete current;
    list->size--;
    return true;
}

//поиск по значению
DNode* dll_find(DoubleList* list, const string& value) {
    //поиск
    DNode* current = list->head;
    while (current != nullptr) {
        if (current->data == value) {
            return current;
        }
        current = current->next;
    }
    return nullptr;
}

//от головы до хвоста
void dll_print_forward(const DoubleList* list) {
    if (list->head == nullptr) {
        cout << "Двусвязный список пуст" << endl;
        return;
    }
    
    cout << "Двусвязный список [" << list->size << "]: ";
    DNode* current = list->head;
    while (current != nullptr) {
        cout << current->data;
        if (current->next != nullptr) {
            cout << " <-> ";
        }
        current = current->next;
    }
    cout << endl;
}

//от хвоста до головы
void dll_print_backward(const DoubleList* list) {
    if (list->tail == nullptr) {
        cout << "Двусвязный список пуст" << endl;
        return;
    }
    
    cout << "Двусвязный список в обратном порядке [" << list->size << "]: ";
    DNode* current = list->tail;
    while (current != nullptr) {
        cout << current->data;
        if (current->prev != nullptr) {
            cout << " <-> ";
        }
        current = current->prev;
    }
    cout << endl;
}

//кол-во элементов
int dll_size(const DoubleList* list) {
    return list->size;
}

//очистка памяти
void dll_free(DoubleList* list) {
    DNode* current = list->head;
    while (current != nullptr) {
        DNode* temp = current;
        current = current->next;
        delete temp;
    }
    delete list;
}




#include "FBT.h"
#include <iostream>
#include <queue>
#include <cmath>
using namespace std;

FullBinaryTree* create_full_binary_tree() {
    FullBinaryTree* tree = new FullBinaryTree;
    tree->root = nullptr;//пустое
    tree->size = 0;
    return tree;
}

// Вспомогательная функция для добавления в полное бинарное дерево
TreeNode* insert_helper(TreeNode* root, int key, const string& value, bool& inserted) {
    if (root == nullptr) {
        inserted = true;
        TreeNode* new_node = new TreeNode;
        new_node->key = key;
        new_node->value = value;
        new_node->left = nullptr;
        new_node->right = nullptr;
        return new_node;
    }
    
    // Для полного бинарного дерева используем обход в ширину
    // и вставляем на первый доступный уровень
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        TreeNode* current = q.front();
        q.pop();
        
        // Если у текущего узла нет левого потомка - вставляем туда
        if (current->left == nullptr) {
            inserted = true;
            current->left = new TreeNode;
            current->left->key = key;
            current->left->value = value;
            current->left->left = nullptr;
            current->left->right = nullptr;
            return root;
        }
        // Если у текущего узла нет правого потомка - вставляем туда
        else if (current->right == nullptr) {
            inserted = true;
            current->right = new TreeNode;
            current->right->key = key;
            current->right->value = value;
            current->right->left = nullptr;
            current->right->right = nullptr;
            return root;
        }
        // Если оба потомка есть, добавляем их в очередь для дальнейшего обхода
        else {
            q.push(current->left);
            q.push(current->right);
        }
    }
    
    return root;
}

// Добавляет новый узел в полное бинарное дерево
bool tree_insert(FullBinaryTree* tree, int key, const string& value) {
    // Сначала проверяем, нет ли уже узла с таким ключом
    if (!tree_search(tree, key).empty()) {
        return false; // Ключ уже существует
    }
    
    bool inserted = false;
    tree->root = insert_helper(tree->root, key, value, inserted);
    if (inserted) {
        tree->size++;
    }
    return inserted;
}

// Рекурсивный поиск
string search_helper(const TreeNode* node, int key) {
    if (node == nullptr) {
        return "";// Узел не найден
    }
    
    if (node->key == key) { // Если нашли узел с нужным ключом
        return node->value;
    }
    
    // Поиск в левом поддереве
    string left_result = search_helper(node->left, key);
    if (!left_result.empty()) {
        return left_result;// Нашли в левом поддереве
    }
    
    // Поиск в правом поддереве
    return search_helper(node->right, key);
}

// Ищет узел по ключу и возвращает его значение
string tree_search(const FullBinaryTree* tree, int key) {
    return search_helper(tree->root, key);
}

// Проверка является ли дерево полным бинарным деревом
bool is_full_binary_tree_helper(const TreeNode* node) {
    if (node == nullptr) {
        return true;
    }
    
    // Если у узла нет детей - это корректно
    if (node->left == nullptr && node->right == nullptr) {
        return true;
    }
    
    // Если у узла оба ребенка - проверяем рекурсивно
    if (node->left != nullptr && node->right != nullptr) {
        return is_full_binary_tree_helper(node->left) && 
               is_full_binary_tree_helper(node->right);
    }
    
    // Если только один ребенок - это не полное бинарное дерево
    return false;
}

// Основная функция проверки свойства полного бинарного дерева
bool is_full_binary_tree(const FullBinaryTree* tree) {
    return is_full_binary_tree_helper(tree->root);
}

// Высота дерева - длина самого длинного пути от корня до листа
int tree_height(const TreeNode* node) {
    if (node == nullptr) {//пустое
        return 0;
    }
    
    //высота поддеревьев
    int left_height = tree_height(node->left);
    int right_height = tree_height(node->right);
    
    return max(left_height, right_height) + 1;// Высота текущего узла = максимальная высота поддеревьев + 1 (текущий узел)
}

// Функция получения количества узлов в дереве
int tree_size(const FullBinaryTree* tree) {
    return tree->size;
}

// Вспомогательные функции для обходов
void inorder_helper(const TreeNode* node) {// Центрированный обход (In-order): левый потомок -> корень -> правый потомок
    if (node == nullptr) return;
    
    inorder_helper(node->left);// Рекурсивно обходим левое поддерево
    cout << node->key << ":" << node->value << " ";
    inorder_helper(node->right);// Рекурсивно обходим правое поддерево
}

void preorder_helper(const TreeNode* node) {// Прямой обход (Pre-order): корень -> левый потомок -> правый потомок
    if (node == nullptr) return;
    
    cout << node->key << ":" << node->value << " ";
    preorder_helper(node->left);// Рекурсивно обходим левое поддерево
    preorder_helper(node->right);// Рекурсивно обходим правое поддерево
}

void postorder_helper(const TreeNode* node) {// Обратный обход (Post-order): левый потомок -> правый потомок -> корень
    if (node == nullptr) return;
    
    postorder_helper(node->left);// Рекурсивно обходим левое поддерево
    postorder_helper(node->right);// Рекурсивно обходим правое поддерево
    cout << node->key << ":" << node->value << " ";
}

// Основные функции обхода дерева
void tree_inorder(const FullBinaryTree* tree) {
    if (tree->root == nullptr) {
        cout << "Дерево пусто" << endl;
        return;
    }
    cout << "Inorder: ";
    inorder_helper(tree->root);
    cout << endl;
}

void tree_preorder(const FullBinaryTree* tree) {
    if (tree->root == nullptr) {
        cout << "Дерево пусто" << endl;
        return;
    }
    cout << "Preorder: ";
    preorder_helper(tree->root);
    cout << endl;
}

void tree_postorder(const FullBinaryTree* tree) {
    if (tree->root == nullptr) {
        cout << "Дерево пусто" << endl;
        return;
    }
    cout << "Postorder: ";
    postorder_helper(tree->root);
    cout << endl;
}

// Обход в ширину (Level-order) с использованием очереди
// Посещает узлы уровень за уровнем, слева направо
void tree_level_order(const FullBinaryTree* tree) {
    if (tree->root == nullptr) {
        cout << "Дерево пусто" << endl;
        return;
    }
    
    cout << "Level order: ";
    queue<const TreeNode*> q;
    q.push(tree->root);
    
    while (!q.empty()) {
        const TreeNode* current = q.front();
        q.pop();
        
        cout << current->key << ":" << current->value << " ";
        
        if (current->left != nullptr) {
            q.push(current->left);
        }
        if (current->right != nullptr) {
            q.push(current->right);
        }
    }
    cout << endl;
}

// Визуальное представление дерева
void print_tree_helper(const TreeNode* root, int space) {
    const int COUNT = 5; // Расстояние между уровнями
    
    if (root == nullptr) {
        return;
    }
    
    space += COUNT;
    
    // Сначала правый узел
    print_tree_helper(root->right, space);
    
    // Текущий узел
    cout << endl;
    for (int i = COUNT; i < space; i++) {
        cout << " ";
    }
    cout << root->key << ":" << root->value << endl;
    
    // Левый узел
    print_tree_helper(root->left, space);
}

void tree_print(const FullBinaryTree* tree) {
    if (tree->root == nullptr) {
        cout << "Tree is empty" << endl;
        return;
    }
    
    cout << "Full Binary Tree structure:" << endl;
    print_tree_helper(tree->root, 0);
    cout << endl;
    
    // Проверка и вывод статуса
    bool is_full = is_full_binary_tree(tree);
    cout << "Is full binary tree: " << (is_full ? "YES" : "NO") << endl;
    cout << "Tree size: " << tree->size << endl;
    cout << "Tree height: " << tree_height(tree->root) << endl;
}

// Освобождение памяти (рекурсивное удаление)
void free_tree_helper(TreeNode* node) {
    if (node == nullptr) {
        return;
    }
    
    free_tree_helper(node->left);
    free_tree_helper(node->right);
    delete node;
}

void tree_free(FullBinaryTree* tree) {
    free_tree_helper(tree->root);
    delete tree;
}



#include "DB.h"
#include <iostream>
#include <string>

int main(int argc, char* argv[]) {
    Database* db = create_database();
    string filename = "database.txt";
    
    cout << "=== Data Structures Database Interface ===" << endl;
    cout << "Type 'HELP' for available commands" << endl;
    cout << "Type 'EXIT' to quit" << endl << endl;
    
    // Автозагрузка базы данных при запуске
    if (load_database(db, filename)) {
        cout << "Database loaded from " << filename << endl;
    }
    
    string command;
    while (true) {
        cout << "> ";
        getline(cin, command);
        
        if (command == "EXIT" || command == "exit") {
            break;
        }
        
        if (!command.empty()) {
            string result = execute_command(db, command);
            cout << result << endl;
            
            // Автосохранение после каждой команды
            save_database(db, filename);
        }
    }
    
    // Финальное сохранение
    save_database(db, filename);
    free_database(db);
    
    cout << "Database saved to " << filename << endl;
    cout << "Goodbye!" << endl;
    
    return 0;
}



#include "Queue.h"
#include <iostream>

//создание очереди
Queue* create_queue(int initial_capacity) {
    Queue* queue = new Queue;
    queue->data = new string[initial_capacity];
    queue->capacity = initial_capacity;
    queue->front = 0; //начало
    queue->rear = -1;//конец
    queue->size = 0;//пустая
    return queue;
}

//добавление
bool queue_push(Queue* queue, const string& value) {
    if (queue->size >= queue->capacity) {
        // Увеличиваем вместимость
        int new_capacity = queue->capacity * 2;
        string* new_data = new string[new_capacity];
        
        // Копируем элементы 
        for (int i = 0; i < queue->size; i++) {
            new_data[i] = queue->data[(queue->front + i) % queue->capacity];
        }
        
        // Освобождаем старый массив и заменяем его новым
        delete[] queue->data;
        queue->data = new_data;
        queue->capacity = new_capacity;
        queue->front = 0;
        queue->rear = queue->size - 1;
    }
    
    
    queue->rear = (queue->rear + 1) % queue->capacity;
    queue->data[queue->rear] = value;
    queue->size++;
    return true;
}

//удаление и возвращение первого элемента 
string queue_pop(Queue* queue) {
    if (queue->size == 0) {
        return ""; // Очередь пуста
    }
    
    //сохраниение элемента
    string value = queue->data[queue->front];
    //сдвиг 
    queue->front = (queue->front + 1) % queue->capacity;
    queue->size--; //уменьшение
    return value;
}

//вывод первого элемента
string queue_peek(const Queue* queue) {
    if (queue->size == 0) {
        return ""; // Очередь пуста
    }
    return queue->data[queue->front];//вывод первого элемента
}

//проверка пустоты
bool queue_is_empty(const Queue* queue) {
    return queue->size == 0;
}

//кол-во
int queue_size(const Queue* queue) {
    return queue->size;
}


//вывод элементов
void queue_print(const Queue* queue) {
    if (queue->size == 0) {
        cout << "очередь пуста" << endl;
        return;
    }
    
    cout << "Очередь (начало -> конец) [" << queue->size << "]: ";
    for (int i = 0; i < queue->size; i++) {
        int index = (queue->front + i) % queue->capacity;
        cout << queue->data[index];
        if (i < queue->size - 1) {
            cout << " -> ";
        }
    }
    cout << endl;
}

//очистка
void queue_free(Queue* queue) {
    delete[] queue->data;
    delete queue;
}


#include "SingleList.h"
#include <iostream>

SingleList* create_singly_linked_list() {
    SingleList* list = new SingleList;
    list->head = nullptr;
    list->tail = nullptr;
    list->size = 0; //начальный размер
    return list;
}

//добавление в голову
void sll_push_front(SingleList* list, const string& value) {
    SNode* new_node = new SNode;
    new_node->data = value;
    new_node->next = list->head; //новый указывает на "старый"
    
    list->head = new_node; 

    //если список пуст, то и голова и хвост
    if (list->tail == nullptr) {
        list->tail = new_node;
    }
    list->size++; //увеличение размера
}

//добавление в хвост
void sll_push_back(SingleList* list, const string& value) {
    SNode* new_node = new SNode;
    new_node->data = value;
    new_node->next = nullptr; // новый хвост
    
    if (list->tail == nullptr) { // если пуст то и голова и хвост
        list->head = new_node;
        list->tail = new_node;
    } else { // после текущего хвоста
        list->tail->next = new_node;
        list->tail = new_node; //обновление
    }
    list->size++;
}

//вставка перед элементом
bool sll_insert_before(SingleList* list, const string& target, const string& value) {
    if (list->head == nullptr) return false; //если пустой
    
    // Если 1 элемент
    if (list->head->data == target) {
        sll_push_front(list, value);
        return true;
    }
    
    // Ищем узел перед элементом
    SNode* current = list->head;
    while (current->next != nullptr && current->next->data != target) {
        current = current->next;
    }
    
    if (current->next == nullptr) return false; // если не найден
    
    // создаем и вставляем узел
    SNode* new_node = new SNode;
    new_node->data = value;
    new_node->next = current->next; //новый указывает на следующий элемент
    current->next = new_node; //старый на новый
    list->size++;
    return true;
}

//вставка после элемента
bool sll_insert_after(SingleList* list, const string& target, const string& value) {
    if (list->head == nullptr) return false;
    
    //поиск 
    SNode* current = list->head;
    while (current != nullptr && current->data != target) {
        current = current->next;
    }
    
    if (current == nullptr) return false; // элемент не найден
    
    // создаем и вставляем узел
    SNode* new_node = new SNode;
    new_node->data = value;
    new_node->next = current->next;
    current->next = new_node; 
    
    if (current == list->tail) { //если после хвоста, то обновляем хвост
        list->tail = new_node;
    }
    list->size++;
    return true;
}

//удаление головы
bool sll_pop_front(SingleList* list) {
    if (list->head == nullptr) return false; //пустой
    
    SNode* temp = list->head; //запоминаем старую голову
    list->head = list->head->next; // узел на след элемент
    
    if (list->head == nullptr) { //если стал пустым,обновление
        list->tail = nullptr;
    }
    
    delete temp; //очистка памяти от старой головы
    list->size--; 
    return true;
}

//удаление хвоста
bool sll_pop_back(SingleList* list) {
    if (list->head == nullptr) return false;//пустой
    
    if (list->head == list->tail) {
        //только 1 элемент
        delete list->head;
        list->head = nullptr;
        list->tail = nullptr;
        list->size--;
        return true;
    }
    
    //поиск предпоследнего узла
    SNode* current = list->head;
    while (current->next != list->tail) {
        current = current->next;
    }

    //удаление и обновление
    delete list->tail;
    current->next = nullptr;
    list->tail = current;
    list->size--;
    return true;
}

//удаление по значению
bool sll_remove_value(SingleList* list, const string& value) {
    if (list->head == nullptr) return false; //пустой
    
    // Если значение в голове
    if (list->head->data == value) {
        return sll_pop_front(list);
    }
    
    //поиск 
    SNode* current = list->head;
    while (current->next != nullptr && current->next->data != value) {
        current = current->next;
    }
    
    if (current->next == nullptr) return false; // значение не найдено
    
    SNode* temp = current->next;
    current->next = temp->next;
    
    if (temp == list->tail) { //хвост, обновление
        list->tail = current;
    }
    
    delete temp;
    list->size--;
    return true;
}

//поиск по значению
SNode* sll_find(SingleList* list, const string& value) {
    SNode* current = list->head;
    while (current != nullptr) {
        if (current->data == value) {
            return current;
        }
        current = current->next;
    }
    return nullptr;
}

//вывод от головы до хвоста
void sll_print_forward(const SingleList* list) {
    if (list->head == nullptr) {
        cout << "Односвязный список пуст" << endl;
        return;
    }
    
    cout << "Односвязный список [" << list->size << "]: ";
    SNode* current = list->head;
    while (current != nullptr) {
        cout << current->data;
        if (current->next != nullptr) {
            cout << " -> ";
        }
        current = current->next;
    }
    cout << endl;
}

//вспомогательная функция для обратного вывода
void sll_print_backward_helper(SNode* node) {
    if (node == nullptr) return;
    sll_print_backward_helper(node->next);
    cout << node->data;
    if (node->next != nullptr) {
        cout << " <- ";
    }
}

void sll_print_backward(const SingleList* list) {
    if (list->head == nullptr) {
        cout << "Односвязный список пуст" << endl;
        return;
    }
    
    cout << "Односвязный список в обратном порядке [" << list->size << "]: ";
    sll_print_backward_helper(list->head);
    cout << endl;
}

//вывод кол-ва
int sll_size(const SingleList* list) {
    return list->size;
}

//очистка памяти
void sll_free(SingleList* list) {
    SNode* current = list->head;
    //последовательное удаление
    while (current != nullptr) {
        SNode* temp = current; //запоминаем
        current = current->next; //переход к следующему
        delete temp; //удаление 
    }
    delete list;
}




#include "Stack.h"
#include <iostream>

//создаем стек
Stack* create_stack(int initial_capacity) {
    Stack* stack = new Stack;
    stack->data = new string[initial_capacity];
    stack->capacity = initial_capacity;
    stack->top = -1; // Стек пуст
    return stack;
}

//добавление в стек
bool stack_push(Stack* stack, const string& value) {
    if (stack->top >= stack->capacity - 1) {
        // Увеличиваем вместимость
        int new_capacity = stack->capacity * 2;
        string* new_data = new string[new_capacity];
        
        for (int i = 0; i <= stack->top; i++) {
            new_data[i] = stack->data[i];
        }
        
        //освобождаем старый и заменяем новым
        delete[] stack->data;
        stack->data = new_data;
        stack->capacity = new_capacity;
    }
    
    stack->top++;
    stack->data[stack->top] = value;
    return true;
}

//удаление
string stack_pop(Stack* stack) {
    if (stack->top < 0) {
        return ""; // Стек пуст
    }
    
    //сохранение элемента и уменьшение 
    string value = stack->data[stack->top];
    stack->top--;
    return value;
}

//вывод
string stack_peek(const Stack* stack) {
    if (stack->top < 0) {
        return ""; // Стек пуст
    }
    return stack->data[stack->top];
}

//проверка пустоты
bool stack_is_empty(const Stack* stack) {
    return stack->top < 0;
}

//кол-во
int stack_size(const Stack* stack) {
    return stack->top + 1;
}

//содержимое
void stack_print(const Stack* stack) {
    if (stack->top < 0) {
        cout << "стек пустой" << endl;
        return;
    }
    
    cout << "Стопка (сверху вниз) [" << (stack->top + 1) << "]: ";
    for (int i = stack->top; i >= 0; i--) {
        cout << stack->data[i];
        if (i > 0) {
            cout << " | ";
        }
    }
    cout << endl;
}

//очистка памяти
void stack_free(Stack* stack) {
    delete[] stack->data;
    delete stack;
}




